import asyncio
import base64
import os
import shutil
import threading
from typing import Optional

import nodriver
from nodriver import cdp

from consts.errors import NotSupportOperation
from utils.util import get_logger

logger = get_logger(__name__)


class Browser:

    _instance = None
    _operation_lock = threading.Lock()

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            logger.info("Create browser")
            cls._instance = super(Browser, cls).__new__(cls, *args, **kwargs)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self, browser_directory="./chrome"):
        if self._initialized:
            return
        self._browser_directory = browser_directory
        self._initialized = True
        self._browser: Optional[nodriver.Browser] = None
        asyncio.run(self.start_browser())

    async def start_browser(self):
        try:
            logger.info(f'Start initializing the browser, Current CHROME_VERSION: {os.environ.get("CHROME_VERSION")}')
            self._delete_chrome_lock()
            self._browser = await nodriver.start(user_data_dir=self._browser_directory,
                                                 browser_args=["--window-size=1600,900",
                                                               "--disable-gpu",
                                                               "--disable-dev-shm-usage"])
            logger.info("Browser is opened")
        except Exception as e:
            logger.exception(e)
            logger.error(f"Start chrome browser error, exit")
            os._exit(-1)

    def _delete_chrome_lock(self):
        """
        Aim to delete the locks generated by Chrome to prevent the browser from starting each time,
         in case Chrome detect some suspicious actions were taken.
        """

        file_to_remove = ['SingletonCookie', 'SingletonLock', 'SingletonSocket']
        with os.scandir(self._browser_directory) as entries:
            for entry in entries:
                if entry.name in file_to_remove:
                    file_path = os.path.join(self._browser_directory, entry.name)
                    os.remove(file_path)
                else:
                    pass
        cache_dir = os.path.join(self._browser_directory, 'Default')
        if os.path.exists(cache_dir):
            for file in os.listdir(cache_dir):
                if file in ('Preferences', "Cache", "Code Cache"):
                    file_path = os.path.join(cache_dir, file)
                    try:
                        if os.path.isdir(file_path):
                            logger.info(f"remove dir: {file_path} ")
                            shutil.rmtree(file_path)
                        else:
                            logger.info(f"remove file: {file_path} ")
                            os.remove(file_path)
                    except Exception:
                        logger.error(f"Delete file error: {file_path}")

    def get_tab(self, tab_number):
        if 0 < tab_number < len(self._browser.tabs):
            return self._browser.tabs[tab_number]
        return self._browser.main_tab

    async def execute(self, func, params):
        if not hasattr(self._browser, func):
            raise NotSupportOperation(f"Not Support Func: {func}")
        method = getattr(self._browser, func)
        if isinstance(params, list):
            return await method(*params)
        elif isinstance(params, dict):
            return await method(**params)
        else:
            return await method(params)

    async def page_source(self, tab_number=0) -> str:
        return await self.get_tab(tab_number).get_content()

    async def screenshot(self, tab_number=0) -> bytes:
        data = await self.get_tab(tab_number).send(
            cdp.page.capture_screenshot(format_="jpeg", capture_beyond_viewport=False))
        return base64.b64decode(data)


CHROME = Browser()
