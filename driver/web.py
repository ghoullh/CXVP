import os.path
import shutil
import threading
import time
import traceback

import psutil
from selenium import webdriver
from selenium.webdriver import Keys
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
import undetected_chromedriver as uc

from utils.util import get_logger

logger = get_logger(__name__)


class Browser:

    _instance = None
    _operation_lock = threading.Lock()

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Browser, cls).__new__(cls, *args, **kwargs)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self, browser_directory="/app/selenium"):
        if self._initialized:
            return
        self._browser_directory = browser_directory
        self._initialized = True
        self._driver: webdriver.Chrome
        self._chrome_version = os.environ.get("CHROME_VERSION")
        logger.info(f"Current CHROME_VERSION: {self._chrome_version}\n"
                    f"Start initializing the browser")
        self._start_browser()
        logger.info("Browser is opened")

    def wait_for_element_clickable(self, selector, by=By.XPATH, timeout=10):
        try:
            return WebDriverWait(self._driver, timeout).until(
                expected_conditions.element_to_be_clickable((by, selector))
            )
        except Exception:
            raise Exception(
                "Element {%s} was not visible/clickable after %s seconds!"
                % (selector, timeout))

    def type(self, selector, text, by=By.XPATH, timeout=10):
        el = self.wait_for_element_clickable(selector, by=by, timeout=timeout)
        el.clear()
        if not text.endswith("\n"):
            el.send_keys(text)
        else:
            el.send_keys(text[:-1])
            el.send_keys(Keys.ENTER)

    def click(self, selector, by=By.XPATH, timeout=10):
        el = self.wait_for_element_clickable(selector, by=by, timeout=timeout)
        el.click()

    def _start_browser(self):
        try:
            self._delete_chrome_lock()
            chrome_options = uc.ChromeOptions()
            chrome_options.add_argument("--window-size=1600,900")
            chrome_options.add_argument("--disable-gpu")
            chrome_options.add_argument("--disable-dev-shm-usage")
            self._driver = uc.Chrome(use_subprocess=False,
                                     options=chrome_options,
                                     user_data_dir=self._browser_directory,
                                     driver_executable_path='/usr/local/bin/chromedriver')

        except Exception as e:
            logger.exception(e)
            logger.error(f"Start chrome browser error, exit")
            os._exit(1)

    def exit(self):
        logger.info("Quit Browser!")
        self._driver.quit()

    def refresh(self):
        logger.info(f"Refresh current page.")
        with self._operation_lock:
            try:
                logger.info(f"Starting refresh current page: {self._driver.current_url}")
                self._driver.refresh()
                time.sleep(15)
                logger.info(f"Finished refresh current page: {self._driver.current_url}")
            except Exception:
                logger.error(f"Refresh page Error:\n {traceback.format_exc()}")
                os._exit(1)

    def restart(self):
        logger.info(
            f"Restarting Browser, memory usage:{sum(p.memory_info().rss for p in psutil.process_iter()) / (1024 * 1024)} ")
        with self._operation_lock:
            self.exit()
            # waiting 30 seconds
            time.sleep(30)
            logger.info(
                f"Start initializing the browser,memory usage: {sum(p.memory_info().rss for p in psutil.process_iter()) / (1024 * 1024)}")
            self._start_browser()
            logger.info(
                f"Browser is opened, memory usage: {sum(p.memory_info().rss for p in psutil.process_iter()) / (1024 * 1024)}")

    def _delete_chrome_lock(self):
        """
        Aim to delete the locks generated by Chrome to prevent the browser from starting each time,
         in case Chrome detect some suspicious actions were taken.
        """

        file_to_remove = ['SingletonCookie', 'SingletonLock', 'SingletonSocket']
        with os.scandir(self._browser_directory) as entries:
            for entry in entries:
                if entry.name in file_to_remove:
                    file_path = os.path.join(self._browser_directory, entry.name)
                    os.remove(file_path)
                else:
                    pass
        cache_dir = os.path.join(self._browser_directory, 'Default')
        if os.path.exists(cache_dir):
            for file in os.listdir(cache_dir):
                if file in ('Preferences', "Cache", "Code Cache"):
                    file_path = os.path.join(cache_dir, file)
                    try:
                        if os.path.isdir(file_path):
                            logger.info(f"remove dir: {file_path} ")
                            shutil.rmtree(file_path)
                        else:
                            logger.info(f"remove file: {file_path} ")
                            os.remove(file_path)
                    except Exception:
                        logger.error(f"Delete file error: {file_path}")


CHROME_BROWSER = Browser()
